#for encrypting LoadLibrary and GetProcAddress strings

from Crypto.Cipher import ARC4

key = bytes([0x4f, 0x5e, 0xc2, 0x35, 0x55, 0xa6, 0x7b, 0xe2, 0x53, 0x15, 0x17, 0x43, 0x8f, 0x96, 0xc4, 0x6f, 0x7f, 0x65, 0x2a, 0x74, 0x29, 0xc4, 0xb3, 0xb6, 0x08, 0x71, 0x52, 0xd9, 0x15, 0x7d, 0xd0, 0x98, 0x0a, 0x32, 0xa9, 0xee, 0xdf, 0xa3, 0x54, 0xe2, 0x67, 0x14, 0xf5, 0x78, 0x9b, 0x1c, 0xe3, 0x8d])
strs = b'User32.dll\0CreateProcessA\0Kernel32.dll\0SendInput'  #string order is intentionally shuffled

print(len(key), len(strs))
assert len(key) == len(strs)  #same len to be less obvious

c = ARC4.new(key)  #RC4 is easy to embed in programs
encstr = c.encrypt(strs)

print(encstr)

print([i for i, v in enumerate(strs) if strs[i - 1] == 0])   #get offsets
print('const unsigned char encstr[' + str(len(encstr)) + '] = {' + ', '.join("0x{:02x}".format(i) for i in encstr) + '};')  #get encrypted string in c form